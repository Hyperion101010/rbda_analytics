import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.NullWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;
import com.opencsv.CSVParser;
import com.opencsv.CSVParserBuilder;

public class NYPDArrestsDataMapper extends Mapper<LongWritable, Text, Text, Text> {

    private static final Map<String, String> SCHEMA = Map.ofEntries(
        Map.entry("ARREST_KEY", "TEXT"),
        Map.entry("ARREST_DATE", "TIMESTAMP"),
        Map.entry("PD_CD", "NUMBER"),
        Map.entry("PD_DESC", "TEXT"),
        Map.entry("KY_CD", "NUMBER"),
        Map.entry("OFNS_DESC", "TEXT"),
        Map.entry("LAW_CODE", "TEXT"),
        Map.entry("LAW_CAT_CD", "TEXT"),
        Map.entry("ARREST_BORO", "TEXT"),
        Map.entry("ARREST_PRECINCT", "NUMBER"),
        Map.entry("JURISDICTION_CODE", "NUMBER"),
        Map.entry("AGE_GROUP", "TEXT"),
        Map.entry("PERP_SEX", "TEXT"),
        Map.entry("PERP_RACE", "TEXT"),
        Map.entry("X_COORD_CD", "TEXT"),
        Map.entry("Y_COORD_CD", "TEXT"),
        Map.entry("Latitude", "NUMBER"),
        Map.entry("Longitude", "NUMBER"),
        Map.entry("Lon_Lat", "POINT")
        // Note: ZIPCODE is NOT in input schema - it's generated by the mapper from Latitude/Longitude
    );

    private static final Set<String> COLUMNS_TO_DROP = Set.of(
        "X_COORD_CD", "Y_COORD_CD", "PERP_RACE", "Lon_Lat"
    );

    private static final DateTimeFormatter INPUT_DATE_FORMATTER = DateTimeFormatter.ofPattern("MM/dd/yyyy");
    private static final DateTimeFormatter OUTPUT_DATE_FORMATTER = DateTimeFormatter.ofPattern("HH:mm:ss MM/dd/yyyy");
    private static final LocalDateTime MIN_DATE = LocalDateTime.of(2015, 1, 1, 0, 0, 0);

    private static final Map<String, String> BORO_MAPPING = Map.of(
        "K", "Brooklyn",
        "Q", "Queens",
        "M", "Manhattan",
        "B", "Bronx",
        "S", "Staten Island"
    );

    private static final Map<String, String> LAW_CAT_MAPPING = Map.of(
        "M", "Misdemeanor",
        "F", "Felony",
        "V", "Violation"
    );


    private static final String[] OUTPUT_COLUMNS = new String[] {
        "ARREST_KEY",
        "ARREST_DATE",
        "OFNS_DESC",
        "PD_CD",
        "KY_CD",
        "LAW_CAT_CD",
        "ARREST_BORO",
        "ARREST_PRECINCT",
        "AGE_GROUP",
        "AGE_MIN",
        "AGE_MAX",
        "PERP_SEX",
        "JURISDICTION_CODE",
        "PD_DESC",
        "LAW_CODE",
        "ZIPCODE"
    };

    private static final Map<String, Integer> COL = CsvSchema.COL;
    
    private CSVParser csvParser;
    private ZipcodeLookup zipcodeLookup;

    @Override
    protected void setup(Context context) throws IOException, InterruptedException {
        super.setup(context);

        csvParser = new CSVParserBuilder()
                .withSeparator(',')
                .withQuoteChar('"')
                .withEscapeChar('\\')
                .build();

        // Load zipcode lookup polygons - REQUIRED, fail if not found
        Configuration conf = context.getConfiguration();
        String zipcodeFile = conf.get("zipcode.bounds.file");
        
        System.out.println("=== MAPPER ZIPCODE CONFIGURATION ===");
        System.out.println("Mapper received zipcode.bounds.file = " + zipcodeFile);
        System.out.println("====================================");
        
        if (zipcodeFile == null || zipcodeFile.isEmpty()) {
            throw new IOException("zipcode.bounds.file configuration parameter is required. " +
                "Provide it using: -D zipcode.bounds.file=<path>");
        }
        
        try {
            zipcodeLookup = new ZipcodeLookup(zipcodeFile, conf);
        } catch (IOException e) {
            throw new IOException("Failed to load zipcode CSV file: " + zipcodeFile + 
                ". Error: " + e.getMessage(), e);
        }
    }

    @Override
    public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {
        String line = value.toString().trim();
        
        if (line.isEmpty()) {
            return;
        }

        if (key.get() == 0 && line.startsWith("ARREST_KEY,")) {
            // skip processing of the csv initial line that might contain column names.
            return;
        }

        String[] fields;
        try {
            fields = csvParser.parseLine(line);
        } catch (Exception e) {
            return;
        }

        if (fields.length < CsvSchema.EXPECTED_COLUMN_COUNT) {
            // only process those rows which have valid number of columns.
            return;
        }

        Map<String, String> record = new HashMap<>();
        for (Map.Entry<String, Integer> entry : COL.entrySet()) {
            String colName = entry.getKey();
            int colIndex = entry.getValue();
            if (colIndex < fields.length) {
                String fieldValue = fields[colIndex].trim();
                record.put(colName, fieldValue);
            }
        }

        String originalDate = record.get("ARREST_DATE");
        boolean willBeDropped = false;
        String dropReason = "";
        
        if (record.get("ARREST_KEY") == null || record.get("ARREST_KEY").isEmpty()) {
            willBeDropped = true;
            dropReason = "MISSING_ARREST_KEY";
        } else if (originalDate == null || originalDate.isEmpty()) {
            willBeDropped = true;
            dropReason = "MISSING_DATE";
        } else {
            try {
                LocalDateTime dateTime;
                if (originalDate.length() == 10) {
                    dateTime = LocalDateTime.parse(originalDate + " 00:00:00", 
                        DateTimeFormatter.ofPattern("MM/dd/yyyy HH:mm:ss"));
                } else {
                    dateTime = LocalDateTime.parse(originalDate, 
                        DateTimeFormatter.ofPattern("MM/dd/yyyy HH:mm:ss"));
                }
                if (dateTime.isBefore(MIN_DATE)) {
                    willBeDropped = true;
                    dropReason = "DATE_BEFORE_2015";
                }
            } catch (Exception e) {
                willBeDropped = true;
                dropReason = "INVALID_DATE";
            }
        }

        Map<String, String> cleanedRecord = validateAndCleanRecord(record);
        
        if (cleanedRecord == null) {
            context.getCounter("STATS", "DROPPED_ROWS").increment(1);
            if (!dropReason.isEmpty()) {
                context.getCounter("STATS", "DROP_REASON_" + dropReason).increment(1);
            }
            return;
        }

        // Only take records that are after 2015.
        String dateStr = cleanedRecord.get("ARREST_DATE");
        if (dateStr == null || dateStr.isEmpty()) {
            context.getCounter("STATS", "DROPPED_ROWS").increment(1);
            context.getCounter("STATS", "DROP_REASON_MISSING_DATE").increment(1);
            return;
        }

        LocalDateTime arrestDate;
        try {
            arrestDate = LocalDateTime.parse(dateStr, OUTPUT_DATE_FORMATTER);
            if (arrestDate.isBefore(MIN_DATE)) {
                context.getCounter("STATS", "DROPPED_ROWS").increment(1);
                context.getCounter("STATS", "DROP_REASON_DATE_BEFORE_2015").increment(1);
                return;
            }
        } catch (DateTimeParseException e) {
            context.getCounter("STATS", "DROPPED_ROWS").increment(1);
            context.getCounter("STATS", "DROP_REASON_INVALID_DATE").increment(1);
            return;
        }
        
        // Record passed validation
        context.getCounter("STATS", "TOTAL_ROWS").increment(1);

        // Perform zipcode lookup from Latitude and Longitude
        String latitude = cleanedRecord.get("Latitude");
        String longitude = cleanedRecord.get("Longitude");
        String zipcode = null;
        
        if (latitude != null && longitude != null && 
            !latitude.isEmpty() && !longitude.isEmpty() &&
            !latitude.equals("0") && !longitude.equals("0")) {
            try {
                double lat = Double.parseDouble(latitude.trim());
                double lon = Double.parseDouble(longitude.trim());
                
                // Check for NaN
                if (!Double.isNaN(lat) && !Double.isNaN(lon)) {
                    zipcode = zipcodeLookup.findZipcode(lat, lon);
                }
            } catch (NumberFormatException e) {
                // Invalid coordinate format
            }
        }

        // Validate ZIPCODE - must be NYC zipcode (100xx to 116xx) or drop that particular row.
        if (!isValidNYCZipcode(zipcode)) {
            context.getCounter("STATS", "DROPPED_ROWS").increment(1);
            context.getCounter("STATS", "DROP_REASON_INVALID_ZIPCODE").increment(1);
            return;
        }

        // Add ZIPCODE to cleaned record
        cleanedRecord.put("ZIPCODE", zipcode);
        
        // No need to include lat and long if we already have valid zipcode.
        cleanedRecord.remove("Latitude");
        cleanedRecord.remove("Longitude");

        StringBuilder csvLine = new StringBuilder();
        for (int i = 0; i < OUTPUT_COLUMNS.length; i++) {
            String col = OUTPUT_COLUMNS[i];
            String val = cleanedRecord.getOrDefault(col, "");
            
            // Escape commas and quotes in values
            if (val.contains(",") || val.contains("\"") || val.contains("\n")) {
                val = "\"" + val.replace("\"", "\"\"") + "\"";
            }
            
            if (i > 0) {
                csvLine.append(",");
            }
            csvLine.append(val);
        }

        // This will go in data output.
        context.write(new Text("DATA:"), new Text(csvLine.toString()));

        // Map Reduce some general statistics of the data.
        String year = String.valueOf(arrestDate.getYear());
        String borough = cleanedRecord.get("ARREST_BORO");
        String dateStrFormatted = arrestDate.format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));
        
        // Crimes per Borough per Year
        if (borough != null && !borough.isEmpty()) {
            context.write(
                new Text("BOROUGH_YEAR:" + borough + ":" + year), 
                new Text("1"));
        }
        
        // Records per day
        context.write(
            new Text("DAILY:" + dateStrFormatted), 
            new Text("1"));
    }


    private Map<String, String> validateAndCleanRecord(Map<String, String> record) {
        Map<String, String> cleaned = new HashMap<>();
        
        for (Map.Entry<String, String> entry : record.entrySet()) {
            String columnName = entry.getKey();
            String value = entry.getValue();
            
            if (COLUMNS_TO_DROP.contains(columnName)) {
                continue;
            }
            
            if (value == null || value.isEmpty() || 
                value.equalsIgnoreCase("NA") || 
                value.equalsIgnoreCase("(null)") ||
                value.equalsIgnoreCase("null")) {
                continue;
            }
            
            String expectedType = SCHEMA.get(columnName);
            if (expectedType == null) {
                continue;
            }
            
            if (columnName.equals("ARREST_DATE")) {
                try {
                    LocalDateTime dateTime;
                    if (value.length() == 10) {
                        dateTime = LocalDateTime.parse(value + " 00:00:00", 
                            DateTimeFormatter.ofPattern("MM/dd/yyyy HH:mm:ss"));
                    } else {
                        dateTime = LocalDateTime.parse(value, 
                            DateTimeFormatter.ofPattern("MM/dd/yyyy HH:mm:ss"));
                    }
                    String formattedDate = dateTime.format(OUTPUT_DATE_FORMATTER);
                    cleaned.put("ARREST_DATE", formattedDate);
                } catch (DateTimeParseException e) {
                    continue;
                }
                continue;
            }
            
            if (columnName.equals("ARREST_BORO")) {
                String borough = BORO_MAPPING.get(value.toUpperCase());
                if (borough != null) {
                    cleaned.put("ARREST_BORO", borough);
                } else {
                    cleaned.put("ARREST_BORO", value);
                }
                continue;
            }
            
            if (columnName.equals("LAW_CAT_CD")) {
                String category = LAW_CAT_MAPPING.get(value.toUpperCase());
                if (category != null) {
                    cleaned.put("LAW_CAT_CD", category);
                } else {
                    cleaned.put("LAW_CAT_CD", value);
                }
                continue;
            }
            
            if (columnName.equals("AGE_GROUP")) {
                String normalizedAge = normalizeAgeGroup(value);
                cleaned.put(columnName, normalizedAge);
                
                String[] parts = normalizedAge.split("-");
                if (parts.length == 2) {
                    try {
                        int minAge = Integer.parseInt(parts[0].trim());
                        int maxAge = Integer.parseInt(parts[1].trim());
                        cleaned.put("AGE_MIN", String.valueOf(minAge));
                        cleaned.put("AGE_MAX", String.valueOf(maxAge));
                    } catch (NumberFormatException e) {
                    }
                }
                continue;
            }
            
            if (columnName.equals("PD_CD") || columnName.equals("KY_CD")) {
                try {
                    double floatValue = Double.parseDouble(value);
                    int intValue = (int) floatValue;
                    cleaned.put(columnName, String.valueOf(intValue));
                } catch (NumberFormatException e) {
                    continue;
                }
                continue;
            }
            
            if (!isValidValue(value, expectedType)) {
                continue;
            }
            
            cleaned.put(columnName, value);
        }
        
        if (!cleaned.containsKey("ARREST_KEY") || cleaned.get("ARREST_KEY").isEmpty()) {
            return null;
        }
        
        if (!cleaned.containsKey("ARREST_DATE")) {
            return null;
        }
        
        return cleaned;
    }

    private boolean isValidValue(String value, String expectedType) {
        try {
            switch (expectedType) {
                case "NUMBER":
                    Double.parseDouble(value);
                    return true;
                case "TEXT":
                    return true;
                case "TIMESTAMP":
                    return true;
                case "POINT":
                    return true;
                default:
                    return true;
            }
        } catch (NumberFormatException e) {
            return false;
        }
    }

    private String normalizeAgeGroup(String ageGroup) {
        if (ageGroup == null || ageGroup.isEmpty()) {
            return ageGroup;
        }
        
        if (ageGroup.equals("<18")) {
            return "0-17";
        }
        
        if (ageGroup.equals("65+") || ageGroup.equals("65-100")) {
            return "65-100";
        }
        
        return ageGroup.trim();
    }

    private boolean isValidNYCZipcode(String zipcode) {
        if (zipcode == null || zipcode.trim().isEmpty()) {
            return false;
        }

        try {
            int zip = Integer.parseInt(zipcode.trim());
            
            // NYC zipcodes: 10000 to 11699 (100xx to 116xx)
            return zip >= 10000 && zip <= 11699;
        } catch (NumberFormatException e) {
            // If zipcode is Nan or Null or anything, this check will return false.
            return false;
        }
    }
}

